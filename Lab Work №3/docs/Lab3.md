# Лабораторная работа №3
**Тема:** Использование принципов проектирования на уровне методов и классов
 
**Цель работы:** Получить опыт проектирования и реализации модулей с использованием принципов KISS, YAGNI, DRY и SOLID
## Диаграмма компонентов
Диаграмма разбита на два фрагмента для удобства чтения. Отдельно вынесен фрагмент, связанный с регистрацией и авторизацией пользователей.
![image](https://github.com/ValeriaSuhinina/hse_paps/assets/126563738/e5bd4252-2342-4014-a55d-801e55dfd3f8)

**Фрагмент диаграммы компонентов, иллюстрирующий процесс авторизации и регистрации пользователей в системе:**
![image](https://github.com/ValeriaSuhinina/hse_paps/assets/126563738/d47d46cf-18b1-48b7-9789-917112accc22)

## Диаграмма последовательностей

Диаграмма последовательностей выполнена для двух вариантов использования: вход в систему и обработка обнаруженного нарушения. Эти два варианта использования наиболее полно отражают взаимосвязь компонентов системы.

![image](https://github.com/ValeriaSuhinina/hse_paps/assets/126563738/3a00f243-2ffb-4f0a-94a6-6ee7646bec16)

![image](https://github.com/ValeriaSuhinina/hse_paps/assets/126563738/aea8b5fa-259b-4157-ba28-b1336c446ed6)

## Модель БД
На диаграмме представлены следующие объекты
- ОбъектНедвижимости: содержит информацию об адресе и типе объекта недвижимости.
- Нарушение: связано с недвижимостью и содержит описание нарушения, его дату, статус устранения, а также информацию о подрядчике и представителе строительного контроля, ответственных за его устранение и контроль соответственно.
- КлассификаторНарушений: Определяет типы нарушений, связанных с объектами недвижимости.
- Подрядчик: содержит информацию об организации подрядчика, связанного с устранением нарушений.
- ПредставительУСК: содержит данные о представителе, ответственном за контроль за устранением нарушений.
- Пользователь: обобщает подрядчика и представителя УСК, содержит информацию о имени и других данных, общих для всех пользователей

  Отношения между объектами позволяют отслеживать, какие нарушения относятся к каким объектам недвижимости, какие типы нарушений существуют и кто ответственен за их устранение и контроль.
![image](https://github.com/ValeriaSuhinina/hse_paps/assets/126563738/4b6e7bb2-8c18-412a-abbc-e2e337eca7f5)

## Применение основных принципов разработки
Пример серверного кода для обработки нарушений

```
class ViolationService:
    def __init__(self):
        self.violations = []

    def addViolation(self, violation):
        self.violations.append(violation)

    def getAllViolations(self):
        return self.violations

    def findViolationsByType(self, violation_type):
        return [violation for violation in self.violations if violation.getDescription() == violation_type]

violation_service = ViolationService()

violation_service.addViolation(violation_1)
violation_service.addViolation(Violation("Another violation", "12/02/2023"))

print(violation_service.getAllViolations())
print(violation_service.findViolationsByType("Another violation"))
```

Этот серверный код демонстрирует использование принципов:
- **KISS:** Простая структура сервиса для управления нарушениями.
- **YAGNI:** Код предоставляет только необходимый функционал для добавления, получения и поиска нарушений.
- **DRY:** Используется метод getAllViolations() для поиска нарушений по их описанию без дублирования логики.
- **SOLID:**  
Single Responsibility Principle: Класс ViolationService отвечает только за управление списком нарушений и операции с ними.  
Open/Closed Principle: Класс ViolationService открыт для расширения (добавление новых методов, например, изменение фильтрации нарушений), но закрыт для изменений внутренней логики работы.  
Liskov Substitution Principle: ViolationService использует объекты типа Violation, сохраняя их в списке и выполняя операции поиска по их типу. Классы, производные от Violation, должны быть заменяемыми на экземпляры базового класса Violation без нарушения работоспособности кода.  
Interface Segregation Principle: В данном примере явно не используются интерфейсы, но если система будет расширяться, можно разделить функциональность на интерфейсы для более четкого определения клиентского кода и избежания зависимости от неиспользуемых методов..  
Dependency Inversion PКласс ViolationService зависит от абстракции (интерфейса Violation или его базового класса), а не от конкретной реализации. Это позволяет избегать прямых зависимостей и облегчает замену реализаций нарушений без изменения ViolationService.

Пример клиентского кода для обработки нарушений

```
property_1 = Property("Address 1", "Residential building")
property_2 = Property("Address 2", "Office building")

violation_1 = Violation("Unauthorized modifications", "12/01/2023")
violation_1.linkToProperty(property_1)

print(violation_1.getDescription())
print(violation_1.getDate())
print(violation_1.linkedTo())
print(property_1.getAddress())

contractor = Contractor("Contractor Organization")
inspector = ConstructionControlRepresentative("Inspector Department")

violation_1.assignContractor(contractor)
violation_1.assignRepresentative(inspector)

```

Этот код использует объекты системы строительного контроля (объектСтроительства, нарушение, подрядчик, представительУСК) в соответствии с принципами:
- **KISS:** Код прост и понятен для использования объектов системы.
- **YAGNI:** Код содержит только необходимые вызовы методов объектов без избыточной функциональности.
- **DRY:** Методы используются для получения информации об объектах (getDescription(), getAddress()), избегая дублирования кода.
- **SOLID:**  
Single Responsibility Principle: Каждый класс (объектСтроительства, нарушение, подрядчик, представительУСК) отвечает за определенные аспекты информации и действий.  
Open/Closed Principle: Код показывает использование существующих классов Property, Violation, Contractor и ConstructionControlRepresentative, но он не изменяет их во время выполнения. Вместо этого он использует их функциональность без модификации.  
Liskov Substitution Principle: Объекты типа Property, Violation, Contractor и ConstructionControlRepresentative могут быть заменены экземплярами их подтипов без нарушения работы кода. Например, любой вид нарушения (Violation) может быть связан с объектом недвижимости (Property), сохраняя связь между ними.  
Interface Segregation Principle: Код не использует интерфейсы явно, но применение интерфейсов в этих классах может помочь клиентам использовать только необходимые методы и атрибуты, избегая зависимости от неиспользуемой функциональности.  
Dependency Inversion Principle: Классы Violation, Contractor, и ConstructionControlRepresentative зависят от абстракций (Property), т.е., они используют объекты абстрактного типа (Property) вместо конкретной реализации, что уменьшает прямые зависимости между классами.
## Дополнительные принципы разработки
- **BDUF (Big Design Up Front) - применим**

**Обоснование:** в случае сложных систем, где необходимо четкое понимание архитектуры до начала разработки, BDUF может быть полезен. Система строительного контроля достаточно статична и должна строго соответствовать регламентам, поэтому требования не будут часто меняться.

- **SoC (Separation of Concerns) - применим**

**Обоснование:** в системе строительного контроля, где различные аспекты, такие как управление нарушениями, информация о недвижимости и участники процесса, могут быть разделены на отдельные компоненты, SoC применим. Это способствует улучшению модульности и облегчает поддержку системы. Разделение ответственности между различными компонентами (например, классы ОбъектСтроительства, Нарушение, Подрядчик, ПредставительУСК) позволяет иметь четкую и понятную структуру системы.

- **MVP (Minimum Viable Product) - применим**

**Обоснование:**  создание MVP в системе строительного контроля позволяет быстро проверить базовую функциональность, необходимую для начала работы системы, и собрать обратную связь от пользователей. Это помогает избежать затрат на разработку ненужных функций и сконцентрироваться на ключевых возможностях. MVP в данной системе позволяет начать с базовых функций (например, управление нарушениями), чтобы быстро предоставить работающий продукт и постепенно добавлять дополнительные возможности на основе обратной связи.

- **PoC (Proof of Concept) - применим**

**Обоснование:** в системе строительного контроля PoC может использоваться для демонстрации работоспособности конкретной идеи или технологии перед ее полной реализацией. Например, применение нового алгоритма для классификации нарушений. PoC позволяет проверить жизнеспособность и эффективность определенной концепции или технологии без затрат на полную реализацию. Это помогает принимать обоснованные решения о внедрении новых возможностей в систему.
